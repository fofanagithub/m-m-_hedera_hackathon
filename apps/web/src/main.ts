import maplibregl from "maplibre-gl";































































import "maplibre-gl/dist/maplibre-gl.css";































































import "./style.css";































































































































type Provider = "maptiler" | "stadia" | "custom";































































































































type ProviderConfig = {































































  provider: Provider;































































  label: string;































































  description: string;































































};































































































































type SnapshotItem = {































































  location: string;































































  value: number;































































  metric?: number | null;































































  ts: number;































































  details?: unknown;































































};































































































































type SnapshotResponse = {































































  kind: string;































































  updated: number;































































  latest: SnapshotItem[];































































  history: SnapshotItem[];































































};































































































































type Feature = {































































  type: "Feature";































































  geometry: { type: "Point"; coordinates: [number, number] };































































  properties: {































































    location: string;































































    value: number;































































    ts: number;































































    details?: unknown;































































  };































































};































































































































type FeatureCollection = {































































  type: "FeatureCollection";































































  features: Feature[];































































};































































































































type DecisionItem = {































































  agent: string;































































  location: string | null;































































  source: string | null;































































  status: string;































































  ts: number;































































  confidence: number | null;































































  actionIndex: number | null;































































  decision: unknown;































































  observation: unknown;































































  policyMetadata: Record<string, unknown> | null;































































  consensus: {































































    topicId: string;































































    sequenceNumber: string | null;































































    consensusTimestamp: string | null;































































  } | null;































































};































































































































type DecisionsResponse = {































































  updated: number;































































  items: DecisionItem[];































































};































































































































const MAP_CENTER: [number, number] = [-13.6075, 9.6403];































































































































const LOCATION_COORDS: Record<string, [number, number]> = {































































  A: [-13.6207, 9.6398],































































  B: [-13.6013, 9.6465],































































  C: [-13.5874, 9.6401],































































  D: [-13.6309, 9.6372],































































  E: [-13.5698, 9.6421],































































  "junction-central": [-13.6049, 9.6428],































































  "junction-north": [-13.5982, 9.6499],































































  "junction-west": [-13.6185, 9.6375],































































  "rail-crossing": [-13.5764, 9.6342],































































};































































































































const PROVIDERS: ProviderConfig[] = [































































  {































































    provider: "maptiler",































































    label: "MapTiler (vector)",































































    description:































































      "Requires a MapTiler API key. Uses the hosted vector style service.",































































  },































































  {































































    provider: "stadia",































































    label: "Stadia Maps (raster)",































































    description:































































      "Requires a Stadia Maps API key. Falls back to open access demo tiles otherwise.",































































  },































































  {































































    provider: "custom",































































    label: "Self-hosted / custom style",































































    description: "Point to your own TileServer GL, Tegola, or MapLibre style URL.",































































  },































































];































































































































function normalizeBaseUrl(raw: string): string {































































  if (!raw) return "";































































  return raw.endsWith("/") ? raw.slice(0, -1) : raw;































































}































































































































const ENV = {































































  maptilerKey: import.meta.env.VITE_MAPTILER_KEY ?? "",































































  maptilerStyleId: import.meta.env.VITE_MAPTILER_STYLE ?? "streets-v2",































































  stadiaKey: import.meta.env.VITE_STADIA_KEY ?? "",































































  stadiaStyleId: import.meta.env.VITE_STADIA_STYLE ?? "alidade_smooth",































































  customStyleUrl:































































    import.meta.env.VITE_CUSTOM_STYLE_URL ??































































    "https://demotiles.maplibre.org/style.json",































































  initialProvider:































































    (import.meta.env.VITE_MAP_PROVIDER as Provider | undefined) ?? "maptiler",































































  backendBaseUrl: normalizeBaseUrl(































































    import.meta.env.VITE_BACKEND_URL ?? "http://localhost:8000",































































  ),































































  trafficRefreshMs: Math.max(































































    1500,































































    Number(import.meta.env.VITE_TRAFFIC_REFRESH_MS ?? 4000) || 4000,































































  ),































































};

const MEME_LOGO_URL = new URL('../logo_mêmê.png', import.meta.url).toString();
































































































































































































function getMetric(item: SnapshotItem): number | null {































































  const metric = Number(item.metric ?? item.value);































































  return Number.isFinite(metric) ? metric : null;































































}































































































































function describeDetails(details: unknown): string | null {































































  if (!details || typeof details !== 'object') return null;































































  const data = details as Record<string, unknown>;































































  const queueNS = Number(data.avg_queue_len_NS ?? data.queue_ns ?? data.queueNS);































































  const queueEW = Number(data.avg_queue_len_EW ?? data.queue_ew ?? data.queueEW);































































  if (Number.isFinite(queueNS) && Number.isFinite(queueEW)) {































































    return `NS ${queueNS.toFixed(0)} / EW ${queueEW.toFixed(0)}`;































































  }































































  const wait = Number(































































    data.wait_time_NS ?? data.wait_time_EW ?? data.wait_ns ?? data.wait_ew,































































  );































































  if (Number.isFinite(wait)) {































































    return `Wait ${wait.toFixed(0)}s`;































































  }































































  const progress = Number(data.progress);































































  if (Number.isFinite(progress)) {































































    const percent = progress <= 1 ? progress * 100 : progress;































































    return `Progress ${percent.toFixed(0)}%`;































































  }































































  return null;































































}































































































































function decisionKey(item: DecisionItem): string {































































  const location = item.location ?? (item.agent === "rail" ? "rail" : "");































































  return `${item.agent}::${location}`.toLowerCase();































































}































































































































function formatDecisionLabel(item: DecisionItem): string {































































  if (item.agent === "rail") {































































    return item.location ? formatLocationLabel(item.location) : "Rail agent";































































  }































































  if (item.location) {































































    return formatLocationLabel(item.location);































































  }































































  return "Traffic agent";































































}































































































































function describeDecisionAction(item: DecisionItem): string {































































  if (item.agent === "traffic" && item.decision && typeof item.decision === "object") {































































    const plan = item.decision as Record<string, unknown>;































































    const nsRaw = typeof plan.ns === "string" ? plan.ns.toUpperCase() : "?";































































    const ewRaw = typeof plan.eo === "string" ? plan.eo.toUpperCase() : "?";































































    const duration = Number(plan.durationSec ?? plan.duration_sec);































































    const durationLabel = Number.isFinite(duration) ? `${Math.round(duration)}s` : "unknown duration";































































    return `Plan: NS ${nsRaw} / EW ${ewRaw} (${durationLabel})`;































































  }































































  if (item.agent === "rail" && item.decision && typeof item.decision === "object") {































































    const command = item.decision as Record<string, unknown>;































































    const state = typeof command.state === "string" ? command.state.toLowerCase() : "unknown";































































    return `Command: barrier ${state}`;































































  }































































  return "Decision details unavailable";































































}































































































































function describeObservationSummary(item: DecisionItem): string | null {































































  if (!item.observation || typeof item.observation !== "object") {































































    return null;































































  }































































  const obs = item.observation as Record<string, unknown>;































































  if (item.agent === "traffic") {































































    const queueNS = Number(obs.queue_ns ?? obs.queueNS);































































    const queueEW = Number(obs.queue_ew ?? obs.queueEW);































































    const waitNS = Number(obs.wait_ns ?? obs.waitNS);































































    const waitEW = Number(obs.wait_ew ?? obs.waitEW);































































    const progress = Number(obs.progress);































































    const parts: string[] = [];































































    if (Number.isFinite(queueNS) || Number.isFinite(queueEW)) {































































      const nsLabel = Number.isFinite(queueNS) ? queueNS.toFixed(0) : "n/a";































































      const ewLabel = Number.isFinite(queueEW) ? queueEW.toFixed(0) : "n/a";































































      parts.push(`Queues NS ${nsLabel} / EW ${ewLabel}`);































































    }































































    if (Number.isFinite(waitNS) || Number.isFinite(waitEW)) {































































      const nsWait = Number.isFinite(waitNS) ? `${Math.round(waitNS)}s` : "n/a";































































      const ewWait = Number.isFinite(waitEW) ? `${Math.round(waitEW)}s` : "n/a";































































      parts.push(`Wait NS ${nsWait} / EW ${ewWait}`);































































    }































































    if (Number.isFinite(progress)) {































































      const pct = progress <= 1 ? progress * 100 : progress;































































      parts.push(`Progress ${pct.toFixed(0)}%`);































































    }































































    return parts.length ? parts.join(" | ") : null;































































  }































































  if (item.agent === "rail") {































































    const etaMs = Number(obs.eta_ms ?? obs.etaMs ?? obs.eta);































































    const barrier = Number(obs.barrier_closed ?? obs.barrierClosed);































































    const parts: string[] = [];































































    if (Number.isFinite(etaMs)) {































































      const seconds = Math.max(0, Math.round(etaMs / 1000));































































      parts.push(`ETA ${seconds}s`);































































    }































































    if (Number.isFinite(barrier)) {































































      parts.push(`Barrier ${barrier >= 0.5 ? "closed" : "open"}`);































































    }































































    return parts.length ? parts.join(" | ") : null;































































  }































































  return null;































































}































































































































function renderDecisionDetails(item: DecisionItem | null) {































































  decisionDetails.innerHTML = "";































































  if (!item) {































































    decisionDetails.textContent = "No decision selected yet.";































































    return;































































  }































































































































  const header = document.createElement("strong");































































  header.textContent = formatDecisionLabel(item);































































  decisionDetails.appendChild(header);































































































































  const actionLine = document.createElement("span");































































  actionLine.className = "decision-line";































































  actionLine.textContent = describeDecisionAction(item);































































  decisionDetails.appendChild(actionLine);































































































































  const statusLine = document.createElement("span");































































  statusLine.className = "decision-line muted";































































  statusLine.textContent = `Updated ${formatRelativeTime(item.ts)} | Status ${item.status}`;































































  decisionDetails.appendChild(statusLine);































































































































  if (item.source) {































































    const sourceLine = document.createElement("span");































































    sourceLine.className = "decision-line";































































    sourceLine.textContent = `Source ${item.source}`;































































    decisionDetails.appendChild(sourceLine);































































  }































































































































  if (typeof item.confidence === "number") {































































    const confidenceLine = document.createElement("span");































































    confidenceLine.className = "decision-line";































































    confidenceLine.textContent = `Confidence ${(item.confidence * 100).toFixed(0)}%`;































































    decisionDetails.appendChild(confidenceLine);































































  }































































































































  if (typeof item.actionIndex === "number") {































































    const actionIndexLine = document.createElement("span");































































    actionIndexLine.className = "decision-line";































































    actionIndexLine.textContent = `Action index ${item.actionIndex}`;































































    decisionDetails.appendChild(actionIndexLine);































































  }































































































































  const observationSummary = describeObservationSummary(item);































































  if (observationSummary) {































































    const observationLine = document.createElement("span");































































    observationLine.className = "decision-line";































































    observationLine.textContent = observationSummary;































































    decisionDetails.appendChild(observationLine);































































  }































































































































  if (item.consensus) {































































    const consensusLine = document.createElement("span");































































    consensusLine.className = "decision-line muted";































































    const seq = item.consensus.sequenceNumber ?? "n/a";































































    const timestamp = item.consensus.consensusTimestamp ?? "pending";































































    consensusLine.textContent = `Consensus topic ${item.consensus.topicId} | seq ${seq} | ts ${timestamp}`;































































    decisionDetails.appendChild(consensusLine);































































  }































































}































































































































async function refreshDecisions() {































































  const endpoint = `${ENV.backendBaseUrl}/control/decisions/latest`;































































  try {































































    const response = await fetch(endpoint, { cache: "no-store" });































































    if (!response.ok) {































































      throw new Error(`HTTP ${response.status}`);































































    }































































    const payload = (await response.json()) as DecisionsResponse;































































    decisionsCache.clear();































































    payload.items.forEach((item) => {































































      decisionsCache.set(decisionKey(item), item);































































    });































































































































    const sortedItems = [...payload.items].sort((a, b) => {































































      if (a.agent !== b.agent) {































































        return a.agent.localeCompare(b.agent);































































      }































































      return formatDecisionLabel(a).localeCompare(formatDecisionLabel(b));































































    });































































































































    decisionSelect.innerHTML = "";































































































































    if (!sortedItems.length) {































































      decisionSelect.disabled = true;































































      selectedDecisionKey = null;































































      decisionsNotice.classList.remove("error");































































      decisionsNotice.textContent = "No decisions yet";































































      decisionDetails.textContent = "Waiting for decisions";































































      return;































































    }































































































































    decisionsNotice.classList.remove("error");































































    decisionsNotice.innerHTML = `<strong>Updated:</strong> ${formatRelativeTime(payload.updated)}`;































































































































    sortedItems.forEach((item) => {































































      const option = document.createElement("option");































































      const key = decisionKey(item);































































      option.value = key;































































      option.textContent = formatDecisionLabel(item);































































      decisionSelect.appendChild(option);































































    });































































































































    decisionSelect.disabled = false;































































































































    if (!selectedDecisionKey || !decisionsCache.has(selectedDecisionKey)) {































































      selectedDecisionKey = decisionSelect.options[0]?.value ?? null;































































    }































































































































    if (selectedDecisionKey) {































































      decisionSelect.value = selectedDecisionKey;































































    }































































































































    const selectedItem = selectedDecisionKey ? decisionsCache.get(selectedDecisionKey) ?? null : null;































































    renderDecisionDetails(selectedItem);































































  } catch (error) {































































    const message = error instanceof Error ? error.message : "Unknown error";































































    decisionsNotice.classList.add("error");































































    decisionsNotice.innerHTML = `<strong>Decisions error:</strong> ${message}`;































































    decisionSelect.disabled = true;































































    decisionSelect.innerHTML = "";































































    selectedDecisionKey = null;































































    decisionDetails.textContent = "Decisions unavailable.";































































  }































































}































































































































function scheduleDecisionRefresh() {































































  if (decisionTimer) {































































    window.clearInterval(decisionTimer);































































  }































































  decisionTimer = window.setInterval(refreshDecisions, ENV.trafficRefreshMs);































































}































































































































function formatLocationLabel(raw: string): string {































































  return raw































































    .replace(/[_-]+/g, ' ')































































    .replace(/\w/g, (char) => char.toUpperCase());































































}































































































































function formatMetric(value: number): string {































































  if (value >= 100) {































































    return Math.round(value).toString();































































  }































































  return value.toFixed(1).replace(/\.0$/, '');































































}































































































































function formatEtaSeconds(etaSeconds: number | null): string {































































  if (etaSeconds === null) {































































    return 'unknown ETA';































































  }































































  if (etaSeconds <= 0) {































































    return 'train at crossing';































































  }































































  if (etaSeconds >= 60) {































































    const minutes = Math.floor(etaSeconds / 60);































































    const seconds = etaSeconds % 60;































































    return seconds ? `${minutes}m ${seconds}s` : `${minutes}m`;































































  }































































  return `${etaSeconds}s`;































































}































































































































const app = document.querySelector<HTMLDivElement>("#app");































































if (!app) {































































  throw new Error("Missing #app container");































































}































































































































const mapContainer = document.createElement("div");































































mapContainer.id = "map";































































app.appendChild(mapContainer);































































































































const panel = document.createElement("aside");































































panel.className = "control-panel";































































panel.id = "control-panel";































































app.appendChild(panel);































































































































const panelHeader = document.createElement("div");































































panelHeader.className = "panel-header";































































panel.appendChild(panelHeader);































































































































const brandGroup = document.createElement("div");































































brandGroup.className = "brand-group";

const brandLogo = document.createElement("img");
brandLogo.src = MEME_LOGO_URL;
brandLogo.alt = "mêmê logo";
brandLogo.className = "brand-logo";
brandGroup.appendChild(brandLogo);
































































panelHeader.appendChild(brandGroup);































































































































const brandTitle = document.createElement("h1");































































brandTitle.className = "brand-title sr-only";































































brandTitle.textContent = "mêmê";































































brandGroup.appendChild(brandTitle);































































































































const brandSubtitle = document.createElement("p");































































brandSubtitle.className = "brand-subtitle";































































brandSubtitle.textContent = "Mobility console";































































brandGroup.appendChild(brandSubtitle);































































































































const brandTagline = document.createElement("p");































































brandTagline.className = "brand-tagline";































































brandTagline.textContent = "Live operations for connected streets and rail.";































































brandGroup.appendChild(brandTagline);































































































































const panelToggle = document.createElement("button");































































panelToggle.type = "button";































































panelToggle.className = "panel-toggle";































































panelToggle.innerHTML = `







  <span class="sr-only">Toggle control panel</span><span class="toggle-label">Hide</span>

































































`;































































panelToggle.setAttribute("aria-controls", panel.id);































































panelHeader.appendChild(panelToggle);































































































































const panelBody = document.createElement("div");































































panelBody.className = "panel-body";































































panel.appendChild(panelBody);































































































































const providerLabel = document.createElement("label");































































providerLabel.textContent = "Tile provider";































































panelBody.appendChild(providerLabel);































































































































const providerSelect = document.createElement("select");































































providerSelect.name = "provider";































































providerLabel.appendChild(providerSelect);































































































































PROVIDERS.forEach((item) => {































































  const option = document.createElement("option");































































  option.value = item.provider;































































  option.textContent = item.label;































































  providerSelect.appendChild(option);































































});































































































































const providerHint = document.createElement("small");































































providerHint.textContent = PROVIDERS[0]?.description ?? "";































































providerLabel.appendChild(providerHint);































































































































































































const styleLabel = document.createElement("label");































































styleLabel.textContent = "Custom style JSON URL";































































panelBody.appendChild(styleLabel);































































































































const styleInput = document.createElement("input");































































styleInput.type = "url";































































styleInput.placeholder = "https://your-tile-server/styles/standard/style.json";































































styleLabel.appendChild(styleInput);































































































































const styleHint = document.createElement("small");































































styleHint.textContent =































































  "Must expose sprites, glyphs, and tile endpoints with CORS enabled.";































































styleLabel.appendChild(styleHint);































































































































const badge = document.createElement("div");































































badge.className = "badge status-chip";































































badge.innerHTML = "<strong>Status:</strong> awaiting configuration";































































panelBody.appendChild(badge);































































































































const notice = document.createElement("div");































































notice.className = "panel-copy";































































notice.textContent =































































  "Select a provider to load tiles. Configure API keys via environment variables.";































































panelBody.appendChild(notice);































































































































const trafficBox = document.createElement("section");































































trafficBox.className = "panel-section panel-section--traffic";































































panelBody.appendChild(trafficBox);































































































































const trafficHeading = document.createElement("h2");































































trafficHeading.className = "section-title";































































trafficHeading.textContent = "Traffic pulse";































































trafficBox.appendChild(trafficHeading);































































































































const trafficStatus = document.createElement("div");































































trafficStatus.className = "status-line";































































trafficStatus.textContent = "Awaiting traffic telemetry";































































trafficBox.appendChild(trafficStatus);































































































































const trafficMetrics = document.createElement("div");































































trafficMetrics.className = "metrics-list";































































trafficBox.appendChild(trafficMetrics);































































































































const railBox = document.createElement("section");































































railBox.className = "panel-section panel-section--rail";































































panelBody.appendChild(railBox);































































































































const railHeading = document.createElement("h2");































































railHeading.className = "section-title";































































railHeading.textContent = "Rail watch";































































railBox.appendChild(railHeading);































































































































const railStatus = document.createElement("div");































































railStatus.className = "status-line";































































railStatus.textContent = "Awaiting rail telemetry";































































railBox.appendChild(railStatus);































































































































const decisionsBox = document.createElement("section");































































decisionsBox.className = "panel-section panel-section--decisions";































































panelBody.appendChild(decisionsBox);































































































































const decisionsHeading = document.createElement("h2");































































decisionsHeading.className = "section-title";































































decisionsHeading.textContent = "Latest decisions";































































decisionsBox.appendChild(decisionsHeading);































































































































const decisionsSelectLabel = document.createElement("label");































































decisionsSelectLabel.textContent = "Agent / intersection";































































decisionsBox.appendChild(decisionsSelectLabel);































































































































const decisionSelect = document.createElement("select");































































decisionSelect.disabled = true;































































decisionsSelectLabel.appendChild(decisionSelect);































































































































const decisionsNotice = document.createElement("div");































































decisionsNotice.className = "status-line";































































decisionsNotice.textContent = "Waiting for decisions";































































decisionsBox.appendChild(decisionsNotice);































































































































const decisionDetails = document.createElement("div");































































decisionDetails.className = "decision-details";































































decisionDetails.textContent = "No decision selected yet.";































































decisionsBox.appendChild(decisionDetails);































































































































decisionSelect.addEventListener("change", () => {































































  selectedDecisionKey = decisionSelect.value || null;































































  const item = selectedDecisionKey ? decisionsCache.get(selectedDecisionKey) ?? null : null;































































  renderDecisionDetails(item);































































});































































































































const panelToggleLabel = panelToggle.querySelector<HTMLSpanElement>(".toggle-label");































































const panelBreakpoint = window.matchMedia("(min-width: 768px)");































































let panelExpanded = panelBreakpoint.matches;































































































































const applyPanelState = (expanded: boolean) => {































































  panelExpanded = expanded;































































  panel.classList.toggle("collapsed", !expanded);































































  panelToggle.setAttribute("aria-expanded", expanded ? "true" : "false");































































  if (panelToggleLabel) {































































    panelToggleLabel.textContent = expanded ? "Hide" : "Show";































































  }































































};































































































































panelToggle.addEventListener("click", () => {































































  applyPanelState(!panelExpanded);































































});































































































































const syncPanelToViewport = (matches: boolean) => {































































  panelToggle.hidden = matches;































































  if (matches) {































































    applyPanelState(true);































































  } else {































































    applyPanelState(panelExpanded);































































  }































































};































































































































applyPanelState(panelExpanded);































































syncPanelToViewport(panelBreakpoint.matches);































































panelBreakpoint.addEventListener("change", (event) => {































































  syncPanelToViewport(event.matches);































































});































































































































const footer = document.createElement("footer");































































footer.textContent = "mêmê | MapLibre GL | OpenStreetMap";































































app.appendChild(footer);































































































































function resolveStyle(































































  provider: Provider,































































  key: string,































































  customUrl: string,































































): { styleUrl: string; status: string } {































































  if (provider === "maptiler") {































































    const trimmedKey = key || ENV.maptilerKey;































































    if (!trimmedKey) {































































      throw new Error(































































        "MapTiler API key missing. Set VITE_MAPTILER_KEY in your environment.",































































      );































































    }































































    const styleId = ENV.maptilerStyleId;































































    return {































































      styleUrl: `https://api.maptiler.com/maps/${styleId}/style.json?key=${trimmedKey}`,































































      status: "MapTiler vector tiles via hosted CDN",































































    };































































  }































































































































  if (provider === "stadia") {































































    const trimmedKey = key || ENV.stadiaKey;































































    const base = `https://tiles.stadiamaps.com/styles/${ENV.stadiaStyleId}/style.json`;































































    if (!trimmedKey) {































































      return {































































        styleUrl: base,































































        status: "Stadia Maps demo tiles (API key missing, limited usage)",































































      };































































    }































































    const url = new URL(base);































































    url.searchParams.set("api_key", trimmedKey);































































    return {































































      styleUrl: url.toString(),































































      status: "Stadia Maps raster tiles with API key",































































    };































































  }































































































































  const resolved = customUrl.trim() || ENV.customStyleUrl;































































  return {































































    styleUrl: resolved,































































    status: "Custom/self-hosted style URL",































































  };































































}































































































































let activeProvider: Provider = ENV.initialProvider;































































let initialStyle: { styleUrl: string; status: string };































































































































try {































































  initialStyle = resolveStyle(activeProvider, "", ENV.customStyleUrl);































































} catch (error) {































































  console.warn("Falling back to custom tiles:", error);































































  activeProvider = "custom";































































  initialStyle = resolveStyle(activeProvider, "", ENV.customStyleUrl);































































}































































































































const map = new maplibregl.Map({































































  container: mapContainer,































































  style: initialStyle.styleUrl,































































  center: MAP_CENTER,































































  zoom: 12,































































  attributionControl: false,































































});































































































































map.addControl(new maplibregl.NavigationControl(), "top-right");































































map.addControl(































































  new maplibregl.AttributionControl({ compact: true }),































































  "bottom-right",































































);































































































































const TRAFFIC_SOURCE_ID = "traffic-live";































































const TRAFFIC_CIRCLE_LAYER_ID = "traffic-circles";































































const TRAFFIC_LABEL_LAYER_ID = "traffic-labels";































































const EMPTY_COLLECTION: FeatureCollection = {































































  type: "FeatureCollection",































































  features: [] as Feature[],































































};































































let lastTrafficCollection: FeatureCollection = EMPTY_COLLECTION;































































let trafficTimer: number | undefined;































































let railTimer: number | undefined;































































let decisionTimer: number | undefined;































































const decisionsCache = new Map<string, DecisionItem>();































































let selectedDecisionKey: string | null = null;































































































































































































const initialIndex = PROVIDERS.findIndex((item) => item.provider === activeProvider);































































providerSelect.selectedIndex = initialIndex >= 0 ? initialIndex : 0;































































styleInput.value = ENV.customStyleUrl;































































































































function syncForm(provider: Provider) {































































  const config = PROVIDERS.find((item) => item.provider === provider);































































  providerHint.textContent = config?.description ?? "";































































































































  if (provider === "custom") {































































    styleLabel.style.display = "";































































    if (!styleInput.value) {































































      styleInput.value = ENV.customStyleUrl;































































    }































































  } else {































































    styleLabel.style.display = "none";































































  }































































}































































































































function ensureTrafficLayers() {































































  if (map.getSource(TRAFFIC_SOURCE_ID)) {































































    return;































































  }































































































































  map.addSource(TRAFFIC_SOURCE_ID, {































































    type: "geojson",































































    data: lastTrafficCollection,































































  });































































































































  map.addLayer({































































    id: TRAFFIC_CIRCLE_LAYER_ID,































































    type: "circle",































































    source: TRAFFIC_SOURCE_ID,































































    paint: {































































      "circle-radius": [































































        "interpolate",































































        ["linear"],































































        ["coalesce", ["get", "value"], 0],































































        0,































































        4,































































        20,































































        10,































































        40,































































        18,































































      ],































































      "circle-color": [































































        "interpolate",































































        ["linear"],































































        ["coalesce", ["get", "value"], 0],































































        0,































































        "#22c55e",































































        20,































































        "#fbbf24",































































        40,































































        "#f97316",































































        60,































































        "#ef4444",































































      ],































































      "circle-opacity": 0.75,































































      "circle-stroke-width": 1,































































      "circle-stroke-color": "#ffffff",































































    },































































  });































































































































  map.addLayer({































































    id: TRAFFIC_LABEL_LAYER_ID,































































    type: "symbol",































































    source: TRAFFIC_SOURCE_ID,































































    layout: {































































      "text-field": [































































        "concat",































































        ["get", "location"],































































        ": ",































































        ["to-string", ["round", ["coalesce", ["get", "value"], 0]]],































































      ],































































      "text-offset": [0, 1.15],































































      "text-size": 12,































































      "text-anchor": "top",































































    },































































    paint: {































































      "text-color": "#0f172a",































































      "text-halo-color": "rgba(255,255,255,0.85)",































































      "text-halo-width": 1.2,































































    },































































  });































































}































































































































function updateTrafficLayer(collection: FeatureCollection) {































































  ensureTrafficLayers();































































  const source = map.getSource(TRAFFIC_SOURCE_ID) as maplibregl.GeoJSONSource | undefined;































































  if (source) {































































    source.setData(collection);































































  }































































}































































































































function formatRelativeTime(ts: number): string {































































  const delta = Date.now() - ts;































































  if (delta < 2000) return "just now";































































  if (delta < 60_000) return `${Math.round(delta / 1000)}s ago`;































































  if (delta < 3_600_000) return `${Math.round(delta / 60_000)}m ago`;































































  return `${Math.round(delta / 3_600_000)}h ago`;































































}































































































































function renderTrafficMetrics(items: SnapshotItem[]) {































































  if (!items.length) {































































    trafficMetrics.innerHTML = "";































































    return;































































  }































































































































  const ranked = items































































    .map((item) => {































































      const metric = getMetric(item);































































      if (metric === null) {































































        return null;































































      }































































      return { item, metric };































































    })































































    .filter((entry): entry is { item: SnapshotItem; metric: number } => Boolean(entry));































































































































  const top = ranked.sort((a, b) => b.metric - a.metric).slice(0, 3);































































  trafficMetrics.innerHTML = top































































    .map(({ item, metric }) => {































































      const relative = formatRelativeTime(item.ts);































































      const label = formatLocationLabel(item.location);































































      const detail = describeDetails(item.details);































































      const metaSegments = detail ? [detail, relative] : [relative];































































      return `































































        <article class="metric-card">































































          <header>































































            <h3>${label}</h3>































































            <span class="metric-value">${formatMetric(metric)} veh</span>































































          </header>































































          <p class="metric-meta">${metaSegments.join(' &bull; ')}</p>































































        </article>































































      `;































































    })































































    .join("");































































}































































































































async function refreshTraffic() {































































  const endpoint = `${ENV.backendBaseUrl}/ingest/snapshot?kind=traffic`;































































































































  try {































































    const response = await fetch(endpoint, { cache: "no-store" });































































    if (!response.ok) {































































      throw new Error(`HTTP ${response.status}`);































































    }































































































































    const payload = (await response.json()) as SnapshotResponse;































































    const features: Feature[] = payload.latest































































      .map((item) => {































































        const metric = getMetric(item);































































        if (metric === null) {































































          return null;































































        }































































        const direct = LOCATION_COORDS[item.location];































































        const fallback = (































































          typeof item.location === "string"































































            ? LOCATION_COORDS[item.location.toUpperCase()]































































            : undefined































































        );































































        const coords = direct ?? fallback ?? MAP_CENTER;































































        return {































































          type: "Feature",































































          geometry: { type: "Point", coordinates: coords },































































          properties: {































































            location: item.location,































































            value: metric,































































            ts: item.ts,































































            details: item.details,































































          },































































        } as Feature;































































      })































































      .filter((feature): feature is Feature => Boolean(feature));































































































































    const collection: FeatureCollection = { type: "FeatureCollection", features };































































    lastTrafficCollection = collection;































































    updateTrafficLayer(collection);































































































































    trafficStatus.classList.remove("error");































































    const activeLocations = new Set(features.map((feature) => feature.properties.location));































































    const updatedLabel = formatRelativeTime(payload.updated);































































    trafficStatus.innerHTML = features.length































































      ? `<strong>Live traffic:</strong> ${activeLocations.size} intersections | updated ${updatedLabel}`































































      : "No traffic measurements yet";































































    renderTrafficMetrics(payload.latest);































































  } catch (error) {































































    const message = error instanceof Error ? error.message : "Unknown error";































































    trafficStatus.classList.add("error");































































    trafficStatus.innerHTML = `<strong>Traffic feed error:</strong> ${message}`;































































    trafficMetrics.innerHTML = "";































































  }































































}































































































































async function refreshRail() {































































  const endpoint = `${ENV.backendBaseUrl}/ingest/snapshot?kind=rail&limit=5`;































































  try {































































    const response = await fetch(endpoint, { cache: "no-store" });































































    if (!response.ok) {































































      throw new Error(`HTTP ${response.status}`);































































    }































































































































    const payload = (await response.json()) as SnapshotResponse;































































    const latestEntry = [...payload.latest].sort((a, b) => b.ts - a.ts)[0];































































































































    if (!latestEntry) {































































      railStatus.classList.remove("error");































































      railStatus.textContent = "No rail telemetry yet";































































      return;































































    }































































































































    const etaDetails = latestEntry.details as { etaMs?: number; eta_ms?: number } | undefined;































































    const etaMsRaw = Number(etaDetails?.etaMs ?? etaDetails?.eta_ms ?? latestEntry.value);































































    const etaSeconds = Number.isFinite(etaMsRaw)































































      ? Math.max(0, Math.round(etaMsRaw / 1000))































































      : null;































































    const label = formatLocationLabel(latestEntry.location);































































    const etaLabel = formatEtaSeconds(etaSeconds);































































    const updatedLabel = formatRelativeTime(latestEntry.ts);































































































































    railStatus.classList.remove("error");































































    railStatus.innerHTML = `<strong>${label}:</strong> ${etaLabel} | updated ${updatedLabel}`;































































  } catch (error) {































































    const message = error instanceof Error ? error.message : "Unknown error";































































    railStatus.classList.add("error");































































    railStatus.innerHTML = `<strong>Rail feed error:</strong> ${message}`;































































  }































































}































































































































function scheduleRailRefresh() {































































  if (railTimer) {































































    window.clearInterval(railTimer);































































  }































































  railTimer = window.setInterval(refreshRail, ENV.trafficRefreshMs);































































}































































function scheduleTrafficRefresh() {































































  if (trafficTimer) {































































    window.clearInterval(trafficTimer);































































  }































































  trafficTimer = window.setInterval(refreshTraffic, ENV.trafficRefreshMs);































































}































































































































map.on("load", () => {































































  ensureTrafficLayers();































































  refreshTraffic();































































  refreshRail();































































  refreshDecisions();































































  scheduleTrafficRefresh();































































  scheduleRailRefresh();































































  scheduleDecisionRefresh();































































});































































































































map.on("style.load", () => {































































  ensureTrafficLayers();































































  updateTrafficLayer(lastTrafficCollection);































































});































































































































function applyStyle() {































































  const provider = providerSelect.value as Provider;































































  activeProvider = provider;































































  const customUrl = styleInput.value.trim();































































































































  try {































































    const { styleUrl, status } = resolveStyle(provider, "", customUrl);































































    map.setStyle(styleUrl, { diff: false });































































    badge.innerHTML = `<strong>Status:</strong> ${status}`;































































  } catch (error) {































































    const message = error instanceof Error ? error.message : "Unknown error";































































    badge.innerHTML = `<strong>Status:</strong> ${message}`;































































    console.error("Failed to set style", error);































































  }































































}































































































































providerSelect.addEventListener("change", () => {































































  const provider = providerSelect.value as Provider;































































  syncForm(provider);































































  applyStyle();































































});































































































































styleInput.addEventListener("change", applyStyle);































































































































syncForm(activeProvider);































































applyStyle();































































































































window.addEventListener("beforeunload", () => {































































  if (trafficTimer) {































































    window.clearInterval(trafficTimer);































































  }































































  if (railTimer) {































































    window.clearInterval(railTimer);































































  }































































  if (decisionTimer) {































































    window.clearInterval(decisionTimer);































































  }































































});































































































































































































































































